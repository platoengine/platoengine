/*
//@HEADER
// *************************************************************************
//   Plato Engine v.1.0: Copyright 2018, National Technology & Engineering
//                    Solutions of Sandia, LLC (NTESS).
//
// Under the terms of Contract DE-NA0003525 with NTESS,
// the U.S. Government retains certain rights in this software.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are
// met:
//
// 1. Redistributions of source code must retain the above copyright
// notice, this list of conditions and the following disclaimer.
//
// 2. Redistributions in binary form must reproduce the above copyright
// notice, this list of conditions and the following disclaimer in the
// documentation and/or other materials provided with the distribution.
//
// 3. Neither the name of the Sandia Corporation nor the names of the
// contributors may be used to endorse or promote products derived from
// this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY SANDIA CORPORATION "AS IS" AND ANY
// EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
// PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL SANDIA CORPORATION OR THE
// CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
// EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
// PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
// PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
// LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
// NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
//
// Questions? Contact the Plato team (plato3D-help@sandia.gov)
//
// *************************************************************************
//@HEADER
*/

/*
 * Plato_Test_Statistics.cpp
 *
 *  Created on: Nov 17, 2017
 */

#include "gtest/gtest.h"

#include "Plato_SromHelpers.hpp"
#include "Plato_DataFactory.hpp"
#include "Plato_Diagnostics.hpp"
#include "Plato_SromObjective.hpp"
#include "Plato_Communication.hpp"
#include "Plato_LinearAlgebra.hpp"
#include "Plato_SromConstraint.hpp"
#include "Plato_SromStatistics.hpp"
#include "Plato_StandardVector.hpp"
#include "Plato_StatisticsUtils.hpp"
#include "Plato_BetaDistribution.hpp"
#include "Plato_NormalDistribution.hpp"
#include "Plato_StandardMultiVector.hpp"
#include "Plato_UniformDistribution.hpp"
#include "Plato_SolveUncertaintyProblem.hpp"
#include "Plato_TrustRegionAlgorithmDataMng.hpp"
#include "Plato_AugmentedLagrangianStageMng.hpp"
#include "Plato_StandardVectorReductionOperations.hpp"

#include "Plato_UnitTestUtils.hpp"

namespace PlatoTest
{

/******************************************************************************//**
 *
 * @brief Return gold values for srom cumulative distribution function unit test.
 * @return gold values for srom cumulative distribution function unit test with the beta distribution
 *
**********************************************************************************/
std::vector<double> get_gold_srom_cdf_values()
{
    std::vector<double> tOutput = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0.0928733249479272, 0.0928733249479272, 0.0928733249479272,
                                   0.0928733249479272, 0.0928733249479272, 0.190906052532916, 0.190906052532916,
                                   0.190906052532916, 0.190906052532916, 0.190906052532916, 0.288690930703639, 0.288690930703639,
                                   0.288690930703639, 0.288690930703639, 0.288690930703639, 0.288690930703639, 0.288690930703639,
                                   0.367629730075966, 0.367629730075966, 0.367629730075966, 0.367629730075966, 0.529617588990538,
                                   0.529617588990538, 0.529617588990538, 0.529617588990538, 0.529617588990538, 0.601588477675527,
                                   0.601588477675527, 0.601588477675527, 0.601588477675527, 0.682965616373511, 0.682965616373511,
                                   0.682965616373511, 0.735501338008689, 0.735501338008689, 0.735501338008689, 0.735501338008689,
                                   0.735501338008689, 0.735501338008689, 0.93631304234016, 0.93631304234016, 0.93631304234016,
                                   0.93631304234016, 0.93631304234016, 0.93631304234016, 0.93631304234016, 0.93631304234016,
                                   0.93631304234016, 0.93631304234016, 0.93631304234016, 0.93631304234016, 0.93631304234016,
                                   0.93631304234016, 0.93631304234016, 0.93631304234016, 0.93631304234016, 0.93631304234016,
                                   0.93631304234016, 0.93631304234016, 0.93631304234016, 0.93631304234016, 0.93631304234016,
                                   0.93631304234016, 0.93631304234016, 0.93631304234016, 0.93631304234016, 0.93631304234016,
                                   0.93631304234016, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1};
    return (tOutput);
}

/******************************************************************************//**
 *
 * @brief Return gold values for beta cumulative distribution function unit test.
 * @return gold values for beta cumulative distribution function unit test
 *
**********************************************************************************/
std::vector<double> get_gold_beta_cdf_values()
{
    std::vector<double> tOutput = {0, 4.18251442858886e-06, 1.87360421565357e-05, 4.50004817470168e-05, 8.37385628098157e-05,
                                 0.000135489125083890, 0.000200664497540694, 0.000279594196842754, 0.000372548742159945,
                                 0.000479754207990887, 0.000601401828383970, 0.000737654698373451, 0.000888652652285164,
                                 0.0010545159353949, 0.0012353480430474, 0.0014312379655670, 0.0016422619969607,
                                 0.0018684852156916, 0.0021099627138546, 0.0023667406298788, 0.0026388570254160,
                                 0.0029263426369642, 0.0032292215255588, 0.0035475116426084, 0.0038812253260747,
                                 0.0042303697382715, 0.0045949472543414, 0.0049749558087518, 0.0053703892058213,
                                 0.0057812373992300, 0.0062074867446354, 0.0066491202288407, 0.0071061176784202,
                                 0.0075784559502643, 0.0080661091061408, 0.0085690485730724, 0.0090872432910760,
                                 0.0096206598496042, 0.0101692626138522, 0.0107330138419441, 0.0113118737938878,
                                 0.0119058008330800, 0.0125147515210493, 0.0131386807060482, 0.0137775416060337,
                                 0.0144312858865201, 0.0150998637337326, 0.0157832239234475, 0.0164813138858653,
                                 0.0171940797668256, 0.0179214664856470, 0.0186634177898433, 0.0194198763069473,
                                 0.0201907835936486, 0.0209760801824377, 0.0217757056259266, 0.0225895985390054,
                                 0.0234176966389782, 0.0242599367838101, 0.0251162550086087, 0.0259865865604479,
                                 0.0268708659316408, 0.0277690268915517, 0.0286810025170388, 0.0296067252216053,
                                 0.0305461267833346, 0.0314991383716788, 0.0324656905731647, 0.0334457134160766,
                                 0.0344391363941720, 0.0354458884894811, 0.0364658981942390, 0.0374990935319951,
                                 0.0385454020779416, 0.0396047509785003, 0.0406770669702058, 0.0417622763979169,
                                 0.0428603052323908, 0.0439710790872496, 0.0450945232353673, 0.0462305626247043,
                                 0.0473791218936146, 0.0485401253856494, 0.0497134971638795, 0.0508991610247576,
                                 0.0520970405115398, 0.0533070589272867, 0.0545291393474593, 0.0557632046321292,
                                 0.0570091774378179, 0.0582669802289787, 0.0595365352891390, 0.0608177647317126,
                                 0.0621105905104987, 0.0634149344298757, 0.0647307181547056, 0.0660578632199570,
                                 0.0673962910400583, 0.0687459229179908, 0.0701066800541325, 0.0714784835548588,
                                 0.0728612544409122, 0.0742549136555464, 0.0756593820724541, 0.0770745805034867,
                                 0.0785004297061699, 0.0799368503910264, 0.0813837632287094, 0.0828410888569527,
                                 0.0843087478873464, 0.0857866609119410, 0.0872747485096862, 0.0887729312527112,
                                 0.0902811297124489, 0.0917992644656111, 0.0933272561000183, 0.0948650252202884,
                                 0.0964124924533898, 0.0979695784540612, 0.0995362039101028, 0.101112289547545, 0.102697756135692,
                                 0.104292524492053, 0.105896515487156, 0.107509650049252, 0.109131849168908, 0.110763033903503,
                                 0.112403125381615, 0.114052044807313, 0.115709713464348, 0.117376052720258, 0.119050984030377,
                                 0.120734428941751, 0.122426309096979, 0.124126546237957, 0.125835062209552, 0.127551778963186,
                                 0.129276618560347, 0.131009503176028, 0.132750355102082, 0.134499096750512, 0.136255650656693,
                                 0.138019939482516, 0.139791886019477, 0.141571413191687, 0.143358444058831, 0.145152901819058,
                                 0.146954709811810, 0.148763791520594, 0.150580070575697, 0.152403470756838, 0.154233915995772,
                                 0.156071330378838, 0.157915638149450, 0.159766763710540, 0.161624631626952, 0.163489166627780,
                                 0.165360293608667, 0.167237937634046, 0.169122023939344, 0.171012477933137, 0.172909225199258,
                                 0.174812191498863, 0.176721302772462, 0.178636485141894, 0.180557664912273, 0.182484768573893,
                                 0.184417722804083, 0.186356454469039, 0.188300890625610, 0.190250958523044, 0.192206585604706,
                                 0.194167699509757, 0.196134228074796, 0.198106099335472, 0.200083241528059, 0.202065583091002,
                                 0.204053052666428, 0.206045579101625, 0.208043091450496, 0.210045518974973, 0.212052791146411,
                                 0.214064837646945, 0.216081588370824, 0.218102973425713, 0.220128923133971, 0.222159368033895,
                                 0.224194238880950, 0.226233466648958, 0.228276982531271, 0.230324717941916, 0.232376604516716,
                                 0.234432574114383, 0.236492558817594, 0.238556490934035, 0.240624302997429, 0.242695927768537,
                                 0.244771298236141, 0.246850347617997, 0.248933009361776, 0.251019217145975, 0.253108904880816,
                                 0.255202006709116, 0.257298457007142, 0.259398190385444, 0.261501141689669, 0.263607246001355,
                                 0.265716438638709, 0.267828655157361, 0.269943831351106, 0.272061903252622, 0.274182807134171,
                                 0.276306479508291, 0.278432857128458, 0.280561876989737, 0.282693476329420, 0.284827592627644,
                                 0.286964163607986, 0.289103127238058, 0.291244421730069, 0.293387985541384, 0.295533757375063,
                                 0.297681676180381, 0.299831681153343, 0.301983711737173, 0.304137707622802, 0.306293608749324,
                                 0.308451355304457, 0.310610887724975, 0.312772146697140, 0.314935073157104, 0.317099608291315,
                                 0.319265693536898, 0.321433270582030, 0.323602281366297, 0.325772668081043, 0.327944373169705,
                                 0.330117339328134, 0.332291509504909, 0.334466826901632, 0.336643234973217, 0.338820677428169,
                                 0.340999098228843, 0.343178441591701, 0.345358651987555, 0.347539674141794, 0.349721453034609,
                                 0.351903933901203, 0.354087062231988, 0.356270783772774, 0.358455044524953, 0.360639790745662,
                                 0.362824968947948, 0.365010525900910, 0.367196408629847, 0.369382564416382, 0.371568940798586,
                                 0.373755485571087, 0.375942146785173, 0.378128872748887, 0.380315612027109, 0.382502313441630,
                                 0.384688926071222, 0.386875399251695, 0.389061682575945, 0.391247725893994, 0.393433479313026,
                                 0.395618893197410, 0.397803918168714, 0.399988505105716, 0.402172605144404, 0.404356169677968,
                                 0.406539150356783, 0.408721499088391, 0.410903168037463, 0.413084109625771, 0.415264276532131,
                                 0.417443621692362, 0.419622098299219, 0.421799659802326, 0.423976259908105, 0.426151852579697,
                                 0.428326392036866, 0.430499832755915, 0.432672129469576, 0.434843237166907, 0.437013111093172,
                                 0.439181706749731, 0.441348979893899, 0.443514886538821, 0.445679382953331, 0.447842425661803,
                                 0.450003971443998, 0.452163977334912, 0.454322400624602, 0.456479198858022, 0.458634329834848,
                                 0.460787751609291, 0.462939422489909, 0.465089301039420, 0.467237346074496, 0.469383516665562,
                                 0.471527772136585, 0.473670072064855, 0.475810376280772, 0.477948644867612, 0.480084838161299,
                                 0.482218916750167, 0.484350841474718, 0.486480573427377, 0.488608073952239, 0.490733304644808,
                                 0.492856227351742, 0.494976804170580, 0.497094997449474, 0.499210769786911, 0.501324084031433,
                                 0.503434903281347, 0.505543190884443, 0.507648910437687, 0.509752025786932, 0.511852501026611,
                                 0.513950300499424, 0.516045388796027, 0.518137730754720, 0.520227291461116, 0.522314036247826,
                                 0.524397930694119, 0.526478940625590, 0.528557032113829, 0.530632171476068, 0.532704325274840,
                                 0.534773460317628, 0.536839543656510, 0.538902542587800, 0.540962424651686, 0.543019157631864,
                                 0.545072709555166, 0.547123048691190, 0.549170143551918, 0.551213962891340, 0.553254475705062,
                                 0.555291651229923, 0.557325458943602, 0.559355868564222, 0.561382850049947, 0.563406373598585,
                                 0.565426409647180, 0.567442928871598, 0.569455902186122, 0.571465300743029, 0.573471095932172,
                                 0.575473259380560, 0.577471762951929, 0.579466578746312, 0.581457679099606, 0.583445036583144,
                                 0.585428624003244, 0.587408414400772, 0.589384381050706, 0.591356497461671, 0.593324737375501,
                                 0.595289074766778, 0.597249483842382, 0.599205939041023, 0.601158415032781, 0.603106886718644,
                                 0.605051329230035, 0.606991717928344, 0.608928028404446, 0.610860236478239, 0.612788318198147,
                                 0.614712249840653, 0.616632007909804, 0.618547569136724, 0.620458910479130, 0.622366009120833,
                                 0.624268842471248, 0.626167388164889, 0.628061624060874, 0.629951528242420, 0.631837079016337,
                                 0.633718254912521, 0.635595034683445, 0.637467397303641, 0.639335321969191, 0.641198788097204,
                                 0.643057775325302, 0.644912263511091, 0.646762232731643, 0.648607663282964, 0.650448535679468,
                                 0.652284830653443, 0.654116529154522, 0.655943612349142, 0.657766061620012, 0.659583858565566,
                                 0.661396984999426, 0.663205422949857, 0.665009154659219, 0.666808162583422, 0.668602429391370,
                                 0.670391937964414, 0.672176671395793, 0.673956612990084, 0.675731746262635, 0.677502054939012,
                                 0.679267522954433, 0.681028134453204, 0.682783873788155, 0.684534725520068, 0.686280674417114,
                                 0.688021705454273, 0.689757803812766, 0.691488954879479, 0.693215144246386, 0.694936357709966,
                                 0.696652581270630, 0.698363801132132, 0.700070003700987, 0.701771175585890, 0.703467303597120,
                                 0.705158374745956, 0.706844376244087, 0.708525295503017, 0.710201120133474, 0.711871837944811,
                                 0.713537436944411, 0.715197905337087, 0.716853231524483, 0.718503404104474, 0.720148411870556,
                                 0.721788243811249, 0.723422889109486, 0.725052337142005, 0.726676577478743, 0.728295599882221,
                                 0.729909394306938, 0.731517950898750, 0.733121259994259, 0.734719312120198, 0.736312097992810,
                                 0.737899608517231, 0.739481834786868, 0.741058768082778, 0.742630399873047, 0.744196721812162,
                                 0.745757725740386, 0.747313403683134, 0.748863747850342, 0.750408750635837, 0.751948404616709,
                                 0.753482702552675, 0.755011637385453, 0.756535202238117, 0.758053390414472, 0.759566195398411,
                                 0.761073610853278, 0.762575630621231, 0.764072248722600, 0.765563459355246, 0.767049256893920,
                                 0.768529635889617, 0.770004591068934, 0.771474117333423, 0.772938209758944, 0.774396863595016,
                                 0.775850074264174, 0.777297837361311, 0.778740148653034, 0.780177004077009, 0.781608399741306,
                                 0.783034331923750, 0.784454797071264, 0.785869791799212, 0.787279312890744, 0.788683357296140,
                                 0.790081922132145, 0.791475004681318, 0.792862602391366, 0.794244712874483, 0.795621333906692,
                                 0.796992463427176, 0.798358099537621, 0.799718240501546, 0.801072884743637, 0.802422030849086,
                                 0.803765677562919, 0.805103823789332, 0.806436468591017, 0.807763611188496, 0.809085250959452,
                                 0.810401387438055, 0.811712020314289, 0.813017149433286, 0.814316774794644, 0.815610896551760,
                                 0.816899515011153, 0.818182630631785, 0.819460244024392, 0.820732355950799, 0.821998967323249,
                                 0.823260079203724, 0.824515692803262, 0.825765809481280, 0.827010430744898, 0.828249558248250,
                                 0.829483193791810, 0.830711339321707, 0.831933996929040, 0.833151168849202, 0.834362857461189,
                                 0.835569065286918, 0.836769794990545, 0.837965049377777, 0.839154831395185, 0.840339144129520,
                                 0.841517990807025, 0.842691374792750, 0.843859299589856, 0.845021768838938, 0.846178786317328,
                                 0.847330355938406, 0.848476481750914, 0.849617167938262, 0.850752418817840, 0.851882238840325,
                                 0.853006632588987, 0.854125604779004, 0.855239160256761, 0.856347303999163, 0.857450041112938,
                                 0.858547376833945, 0.859639316526482, 0.860725865682585, 0.861807029921340, 0.862882814988184,
                                 0.863953226754211, 0.865018271215474, 0.866077954492290, 0.867132282828546, 0.868181262590997,
                                 0.869224900268571, 0.870263202471673, 0.871296175931485, 0.872323827499270, 0.873346164145671,
                                 0.874363192960013, 0.875374921149607, 0.876381356039047, 0.877382505069511, 0.878378375798065,
                                 0.879368975896958, 0.880354313152926, 0.881334395466489, 0.882309230851251, 0.883278827433202,
                                 0.884243193450012, 0.885202337250333, 0.886156267293099, 0.887104992146822, 0.888048520488889,
                                 0.888986861104865, 0.889920022887787, 0.890848014837465, 0.891770846059775, 0.892688525765963,
                                 0.893601063271938, 0.894508467997569, 0.895410749465986, 0.896307917302876, 0.897199981235778,
                                 0.898086951093382, 0.898968836804824, 0.899845648398988, 0.900717396003797, 0.901584089845511,
                                 0.902445740248028, 0.903302357632175, 0.904153952515010, 0.905000535509114, 0.905842117321891,
                                 0.906678708754863, 0.907510320702968, 0.908336964153854, 0.909158650187182, 0.909975389973913,
                                 0.910787194775613, 0.911594075943748, 0.912396044918977, 0.913193113230453, 0.913985292495120,
                                 0.914772594417007, 0.915555030786527, 0.916332613479775, 0.917105354457822, 0.917873265766016,
                                 0.918636359533279, 0.919394647971403, 0.920148143374346, 0.920896858117536, 0.921640804657161,
                                 0.922379995529474, 0.923114443350087, 0.923844160813271, 0.924569160691254, 0.925289455833519,
                                 0.926005059166106, 0.926715983690906, 0.927422242484964, 0.928123848699779, 0.928820815560599,
                                 0.929513156365725, 0.930200884485811, 0.930884013363162, 0.931562556511034, 0.932236527512938,
                                 0.932905940021939, 0.933570807759957, 0.934231144517068, 0.934886964150808, 0.935538280585473,
                                 0.936185107811420, 0.936827459884373, 0.937465350924724, 0.938098795116835, 0.938727806708344,
                                 0.939352400009466, 0.939972589392298, 0.940588389290126, 0.941199814196724, 0.941806878665667,
                                 0.942409597309626, 0.943007984799685, 0.943602055864638, 0.944191825290300, 0.944777307918814,
                                 0.945358518647955, 0.945935472430441, 0.946508184273241, 0.947076669236878, 0.947640942434745,
                                 0.948201019032411, 0.948756914246928, 0.949308643346146, 0.949856221648021, 0.950399664519925,
                                 0.950938987377958, 0.951474205686262, 0.952005334956329, 0.952532390746318, 0.953055388660367,
                                 0.953574344347903, 0.954089273502962, 0.954600191863501, 0.955107115210712, 0.955610059368340,
                                 0.956109040201996, 0.956604073618478, 0.957095175565085, 0.957582362028937, 0.958065649036291,
                                 0.958545052651862, 0.959020588978141, 0.959492274154716, 0.959960124357593, 0.960424155798516,
                                 0.960884384724288, 0.961340827416097, 0.961793500188834, 0.962242419390422, 0.962687601401135,
                                 0.963129062632926, 0.963566819528752, 0.964000888561901, 0.964431286235314, 0.964858029080920,
                                 0.965281133658956, 0.965700616557303, 0.966116494390810, 0.966528783800627, 0.966937501453535,
                                 0.967342664041276, 0.967744288279889, 0.968142390909038, 0.968536988691350, 0.968928098411745,
                                 0.969315736876776, 0.969699920913959, 0.970080667371116, 0.970457993115707, 0.970831915034170,
                                 0.971202450031261, 0.971569615029392, 0.971933426967972, 0.972293902802746, 0.972651059505143,
                                 0.973004914061612, 0.973355483472970, 0.973702784753743, 0.974046834931515, 0.974387651046273,
                                 0.974725250149750, 0.975059649304779, 0.975390865584639, 0.975718916072402, 0.976043817860287,
                                 0.976365588049011, 0.976684243747139, 0.976999802070439, 0.977312280141235, 0.977621695087763,
                                 0.977928064043526, 0.978231404146651, 0.978531732539246, 0.978829066366762, 0.979123422777348,
                                 0.979414818921214, 0.979703271949994, 0.979988799016105, 0.980271417272113, 0.980551143870099,
                                 0.980827995961022, 0.981101990694085, 0.981373145216106, 0.981641476670883, 0.981907002198567,
                                 0.982169738935031, 0.982429704011242, 0.982686914552633, 0.982941387678479, 0.983193140501271,
                                 0.983442190126094, 0.983688553649998, 0.983932248161386, 0.984173290739385, 0.984411698453232,
                                 0.984647488361653, 0.984880677512247, 0.985111282940870, 0.985339321671021, 0.985564810713226,
                                 0.985787767064429, 0.986008207707378, 0.986226149610017, 0.986441609724876, 0.986654604988464,
                                 0.986865152320663, 0.987073268624123, 0.987278970783656, 0.987482275665637, 0.987683200117401,
                                 0.987881760966643, 0.988077975020819, 0.988271859066550, 0.988463429869024, 0.988652704171403,
                                 0.988839698694230, 0.989024430134834, 0.989206915166743, 0.989387170439091, 0.989565212576034,
                                 0.989741058176161, 0.989914723811909, 0.990086226028979, 0.990255581345755, 0.990422806252723,
                                 0.990587917211889, 0.990750930656205, 0.990911862988989, 0.991070730583351, 0.991227549781622,
                                 0.991382336894777, 0.991535108201868, 0.991685879949455, 0.991834668351035, 0.991981489586482,
                                 0.992126359801477, 0.992269295106946, 0.992410311578503, 0.992549425255884, 0.992686652142396,
                                 0.992822008204353, 0.992955509370527, 0.993087171531592, 0.993217010539574, 0.993345042207298,
                                 0.993471282307846, 0.993595746574002, 0.993718450697715, 0.993839410329551, 0.993958641078154,
                                 0.994076158509706, 0.994191978147388, 0.994306115470846, 0.994418585915654, 0.994529404872783,
                                 0.994638587688071, 0.994746149661694, 0.994852106047637, 0.994956472053171, 0.995059262838328,
                                 0.995160493515383, 0.995260179148328, 0.995358334752363, 0.995454975293372, 0.995550115687415,
                                 0.995643770800213, 0.995735955446641, 0.995826684390218, 0.995915972342601, 0.996003833963084,
                                 0.996090283858092, 0.996175336580687, 0.996259006630063, 0.996341308451058, 0.996422256433657,
                                 0.996501864912498, 0.996580148166390, 0.996657120417819, 0.996732795832466, 0.996807188518726,
                                 0.996880312527226, 0.996952181850344, 0.997022810421740, 0.997092212115875, 0.997160400747545,
                                 0.997227390071409, 0.997293193781522, 0.997357825510874, 0.997421298830924, 0.997483627251142,
                                 0.997544824218553, 0.997604903117279, 0.997663877268090, 0.997721759927952, 0.997778564289581,
                                 0.997834303480995, 0.997888990565078, 0.997942638539131, 0.997995260334443, 0.998046868815853,
                                 0.998097476781316, 0.998147096961478, 0.998195742019246, 0.998243424549364, 0.998290157077994,
                                 0.998335952062294, 0.998380821890006, 0.998424778879041, 0.998467835277068, 0.998510003261108,
                                 0.998551294937128, 0.998591722339642, 0.998631297431310, 0.998670032102542, 0.998707938171109,
                                 0.998745027381747, 0.998781311405776, 0.998816801840714, 0.998851510209897, 0.998885447962099,
                                 0.998918626471161, 0.998951057035621, 0.998982750878341, 0.999013719146146, 0.999043972909463,
                                 0.999073523161962, 0.999102380820201, 0.999130556723274, 0.999158061632466, 0.999184906230906,
                                 0.999211101123227, 0.999236656835229, 0.999261583813545, 0.999285892425309, 0.999309592957833,
                                 0.999332695618281, 0.999355210533352, 0.999377147748962, 0.999398517229937, 0.999419328859698,
                                 0.999439592439967, 0.999459317690457, 0.999478514248583, 0.999497191669167, 0.999515359424152,
                                 0.999533026902316, 0.999550203408996, 0.999566898165809, 0.999583120310382, 0.999598878896088,
                                 0.999614182891779, 0.999629041181534, 0.999643462564398, 0.999657455754141, 0.999671029379010,
                                 0.999684191981487, 0.999696952018059, 0.999709317858985, 0.999721297788072, 0.999732900002453,
                                 0.999744132612374, 0.999755003640982, 0.999765521024119, 0.999775692610125, 0.999785526159640,
                                 0.999795029345419, 0.999804209752141, 0.999813074876237, 0.999821632125715, 0.999829888819990,
                                 0.999837852189727, 0.999845529376681, 0.999852927433551, 0.999860053323833, 0.999866913921684,
                                 0.999873516011790, 0.999879866289240, 0.999885971359408, 0.999891837737842, 0.999897471850155,
                                 0.999902880031929, 0.999908068528620, 0.999913043495475, 0.999917810997454, 0.999922377009157,
                                 0.999926747414763, 0.999930928007971, 0.999934924491952, 0.999938742479314, 0.999942387492058,
                                 0.999945864961564, 0.999949180228568, 0.999952338543156, 0.999955345064765, 0.999958204862189,
                                 0.999960922913603, 0.999963504106583, 0.999965953238146, 0.999968275014798, 0.999970474052585,
                                 0.999972554877163, 0.999974521923870, 0.999976379537816, 0.999978131973977, 0.999979783397304,
                                 0.999981337882844, 0.999982799415866, 0.999984171892008, 0.999985459117431, 0.999986664808984,
                                 0.999987792594384, 0.999988846012411, 0.999989828513115, 0.999990743458034, 0.999991594120432,
                                 0.999992383685547, 0.999993115250856, 0.999993791826359, 0.999994416334874, 0.999994991612352,
                                 0.999995520408209, 0.999996005385678, 0.999996449122175, 0.999996854109692, 0.999997222755203,
                                 0.999997557381095, 0.999997860225620, 0.999998133443374, 0.999998379105795, 0.999998599201686,
                                 0.999998795637770, 0.999998970239269, 0.999999124750510, 0.999999260835571, 0.999999380078947,
                                 0.999999483986260, 0.999999573985005, 0.999999651425327, 0.999999717580853, 0.999999773649554,
                                 0.999999820754667, 0.999999859945661, 0.999999892199262, 0.999999918420540, 0.999999939444061,
                                 0.999999956035110, 0.999999968890998, 0.999999978642463, 0.999999985855159, 0.999999991031280,
                                 0.999999994611299, 0.999999996975875, 0.999999998447931, 0.999999999294973, 0.999999999731666,
                                 0.999999999922788, 0.999999999986664, 0.999999999999338, 1};
    return (tOutput);
}

// ********************************************** BEGIN UNIT TESTS **********************************************

TEST(PlatoTest, ReadCorrelationMatrixFile)
{
    Plato::io::MetaData tFileMetaData;
    tFileMetaData.mFilename = "correlation_matrix.txt";
    std::vector<std::vector<double>> tGold =
        { {0.142166323166496, 0.138671023863737}, {0.138671023863737, 0.141194790885173} };
    Plato::io::write_matrix_to_file(tGold, tFileMetaData);
    auto tOutput = Plato::io::read_matrix_from_file<double>(tFileMetaData.mFilename);

    auto tTol = 1e-6;
    for(auto& tRow : tOutput)
    {
        auto tRowIndex = &tRow - &tOutput[0];
        for(auto& tColValue : tRow)
        {
            auto tColIndex = &tColValue - &tRow[0];
            ASSERT_NEAR(tGold[tRowIndex][tColIndex], tColValue, tTol);
        }
    }

    Plato::system("rm -f correlation_matrix.txt");
}

TEST(PlatoTest, CopyCorrelationMatrix)
{
    Plato::io::MetaData tFileMetaData;
    tFileMetaData.mFilename = "correlation_matrix.txt";
    std::vector<std::vector<double>> tGold =
        { {0.142166323166496, 0.138671023863737}, {0.138671023863737, 0.141194790885173} };
    Plato::StandardMultiVector<double> tMatrix(2,2);
    Plato::copy(tGold, tMatrix);

    auto tTol = 1e-6;
    for(auto& tRow : tGold)
    {
        auto tRowIndex = &tRow - &tGold[0];
        for(auto& tGoldValue : tRow)
        {
            auto tColIndex = &tGoldValue - &tRow[0];
            ASSERT_NEAR(tGoldValue, tMatrix(tRowIndex,tColIndex), tTol);
        }
    }
}

TEST(PlatoTest, SetCorrelationMatrix)
{
    // ********* WRITE CORRELATION MATRIX *********
    Plato::io::MetaData tFileMetaData;
    tFileMetaData.mFilename = "correlation_matrix.txt";
    std::vector<std::vector<double>> tGold =
        { {0.142166323166496, 0.138671023863737}, {0.138671023863737, 0.141194790885173} };
    Plato::io::write_matrix_to_file(tGold, tFileMetaData);

    // ********* DEFINE STATISTICS *********
    const double tMean = 90;
    const double tMax = 135;
    const double tMin = 67.5;
    const double tVariance = 135;
    std::shared_ptr<Plato::BetaDistribution<double>> tDistribution =
            std::make_shared<Plato::BetaDistribution<double>>(tMin, tMax, tMean, tVariance);

    const size_t tNumSamples = 4;
    const size_t tRandomVecDim = 2;
    const size_t tMaxNumMoments = 4;
    Plato::SromInputs<double> tSromData;
    tSromData.mCorrelationMatrixFilename = tFileMetaData.mFilename;
    Plato::SromObjective<double> tObjective(tDistribution, tMaxNumMoments, tNumSamples, tRandomVecDim);
    Plato::set_correlation_matrix(tSromData, tObjective);

    auto tTol = 1e-6;
    const auto& tTruthCorrelation = tObjective.getTruthCorrelationMatrix();
    for(auto& tRow : tGold)
    {
        auto tRowIndex = &tRow - &tGold[0];
        for(auto& tGoldValue : tRow)
        {
            auto tColIndex = &tGoldValue - &tRow[0];
            ASSERT_NEAR(tGoldValue, tTruthCorrelation(tRowIndex,tColIndex), tTol);
        }
    }

    Plato::system("rm -f correlation_matrix.txt");
}

TEST(PlatoTest, ComputeCorrelationMisfit)
{
    size_t tRandVecDim = 2;
    Plato::StandardMultiVector<double> tSromCorrelation(tRandVecDim, tRandVecDim);
    tSromCorrelation(0,0) = 0.204886210166187;
    tSromCorrelation(0,1) = 0.194398490655844;
    tSromCorrelation(1,0) = 0.194398490655844;
    tSromCorrelation(1,1) = 0.184790133740104;
    Plato::StandardMultiVector<double> tTruthCorrelation(tRandVecDim, tRandVecDim);
    tTruthCorrelation(0,0) = 0.164508509700266;
    tTruthCorrelation(0,1) = 0.163872409575874;
    tTruthCorrelation(1,0) = 0.163872409575874;
    tTruthCorrelation(1,1) = 0.164031222859721;
    auto tError = Plato::compute_correlation_misfit(tSromCorrelation, tTruthCorrelation);

    double tTol = 1e-6;
    double tGold = 0.0347000761289629;
    ASSERT_NEAR(tGold, tError, tTol);
}

TEST(PlatoTest, SromCorrelation)
{
    size_t tRandVecDim = 2;
    Plato::StandardVector<double> tProbabilities({0.2, 0.2, 0.2, 0.2, 0.2});
    Plato::StandardMultiVector<double> tCorrelation(tRandVecDim, tRandVecDim);
    Plato::StandardMultiVector<double> tSamples(tRandVecDim, tProbabilities.size());
    tSamples(0,0) = 0.459294009098931;
    tSamples(0,1) = 0.475238872703205;
    tSamples(0,2) = 0.483445281537777;
    tSamples(0,3) = 0.370173255796611;
    tSamples(0,4) = 0.473742039581547;
    tSamples(1,0) = 0.419721090353485;
    tSamples(1,1) = 0.460840629149375;
    tSamples(1,2) = 0.505947416537821;
    tSamples(1,3) = 0.424073928225453;
    tSamples(1,4) = 0.474440939750859;

    Plato::compute_srom_correlation_matrix(tProbabilities, tSamples, tCorrelation);

    double tTol = 1e-6;
    std::vector<std::vector<double>> tGold =  { {0.206396414507494, 0.207625219956856}, {0.207625219956856, 0.209891113875170} };
    for(decltype(tRandVecDim) tIndexI = 0; tIndexI < tRandVecDim; tIndexI++)
    {
        for(decltype(tRandVecDim) tIndexJ = 0; tIndexJ < tRandVecDim; tIndexJ++)
        {
            ASSERT_NEAR(tGold[tIndexI][tIndexJ], tCorrelation(tIndexI, tIndexJ), tTol);
        }
    }
}

TEST(PlatoTest, stats_mean)
{
    size_t tNumSamples = 10;
    Plato::StandardVector<double> tVector(tNumSamples, 1.0);
    Plato::StandardVectorReductionOperations<double> tReduction;
    double tOutput = Plato::mean(tReduction, tVector);
    double tTolerance = 1e-6;
    EXPECT_NEAR(1.0, tOutput, tTolerance);
}

TEST(PlatoTest, stats_stddev)
{
    std::vector<double> tData = { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 };
    Plato::StandardVector<double> tVector(tData);
    Plato::StandardVectorReductionOperations<double> tReduction;

    const double tMean = Plato::mean(tReduction, tVector);
    const double tStdDev = Plato::standard_deviation(tMean, tVector, tReduction);

    const double tTolerance = 1e-6;
    EXPECT_NEAR(5.5, tMean, tTolerance);
    EXPECT_NEAR(3.0276503540974917, tStdDev, tTolerance);
}

TEST(PlatoTest, stats_stddev_one_value)
{
    std::vector<double> tData = { 1 };
    Plato::StandardVector<double> tVector(tData);
    Plato::StandardVectorReductionOperations<double> tReduction;

    const double tMean = Plato::mean(tReduction, tVector);
    const double tStdDev = Plato::standard_deviation(tMean, tVector, tReduction);

    const double tTolerance = 1e-6;
    EXPECT_NEAR(1.0, tMean, tTolerance);
    EXPECT_NEAR(0.0, tStdDev, tTolerance);
}

TEST(PlatoTest, ComputeMonteCarloDataErrors)
{
    Plato::SromInputs<double> tStatsInputs;
    tStatsInputs.mMean = 90.;
    tStatsInputs.mUpperBound = 135.;
    tStatsInputs.mLowerBound = 67.5;
    tStatsInputs.mVariance = 135.;
    tStatsInputs.mNumSamples = 10;
    Plato::BetaDistribution<double> tDistribution(tStatsInputs.mLowerBound, tStatsInputs.mUpperBound, tStatsInputs.mMean, tStatsInputs.mVariance);

    Plato::StandardVector<double> tCDF_1(tStatsInputs.mNumSamples);
    Plato::StandardVector<double> tSamples_1(tStatsInputs.mNumSamples);
    ASSERT_THROW(Plato::compute_monte_carlo_data(tStatsInputs.mNumSamples, tDistribution, tSamples_1, tCDF_1), std::runtime_error);

    Plato::StandardVector<double> tCDF_2(tStatsInputs.mNumSamples + 1);
    Plato::StandardVector<double> tSamples_2(tStatsInputs.mNumSamples);
    ASSERT_THROW(Plato::compute_monte_carlo_data(tStatsInputs.mNumSamples, tDistribution, tSamples_2, tCDF_2), std::runtime_error);
}

TEST(PlatoTest, ComputeMonteCarloData)
{
    Plato::SromInputs<double> tStatsInputs;
    tStatsInputs.mMean = 90.;
    tStatsInputs.mUpperBound = 135.;
    tStatsInputs.mLowerBound = 67.5;
    tStatsInputs.mVariance = 135.;
    tStatsInputs.mNumSamples = 10;
    Plato::BetaDistribution<double> tDistribution(tStatsInputs.mLowerBound, tStatsInputs.mUpperBound, tStatsInputs.mMean, tStatsInputs.mVariance);

    Plato::StandardVector<double> tCDF(tStatsInputs.mNumSamples + 1);
    Plato::StandardVector<double> tSamples(tStatsInputs.mNumSamples + 1);
    ASSERT_NO_THROW(Plato::compute_monte_carlo_data(tStatsInputs.mNumSamples, tDistribution, tSamples, tCDF));

    const double tTolerance = 1e-4;
    std::vector<double> tGoldSamples = {0, 0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9, 1};
    std::vector<double> tGoldCDF = {0, 0.0714785, 0.251019, 0.467237, 0.666808, 0.820732, 0.920897, 0.974047, 0.994957, 0.999721, 0.999987};
    for(size_t tIndex = 0; tIndex < tCDF.size(); tIndex++)
    {
        EXPECT_NEAR(tCDF[tIndex], tGoldCDF[tIndex], tTolerance);
        EXPECT_NEAR(tSamples[tIndex], tGoldSamples[tIndex], tTolerance);
    }
}

TEST(PlatoTest, ComputeUnnormalizedSamples)
{
    double tUpperBound = 135.;
    double tLowerBound = 67.5;
    std::vector<double> tValues = {0, 0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9, 1};

    Plato::StandardVector<double> VecOne(tValues);
    Plato::StandardVector<double> VecTwo(9 /* size */);
    ASSERT_THROW(Plato::compute_unnormalized_samples(tLowerBound, tUpperBound, VecOne, VecTwo), std::runtime_error);

    Plato::StandardVector<double> tNormalized(tValues);
    Plato::StandardVector<double> tUnnormalized(tValues.size());
    ASSERT_NO_THROW(Plato::compute_unnormalized_samples(tLowerBound, tUpperBound, tNormalized, tUnnormalized));

    const double tTolerance = 1e-4;
    std::vector<double> tGoldValues = {67.5, 74.25, 81, 87.75, 94.5, 101.25, 108, 114.75, 121.5, 128.25, 135};
    for(size_t tIndex = 0; tIndex < tNormalized.size(); tIndex++)
    {
        EXPECT_NEAR(tUnnormalized[tIndex], tGoldValues[tIndex], tTolerance);
    }
}

TEST(PlatoTest, PrintCumulativeDistributionFunctionToFile)
{
    Plato::CommWrapper tCommWrapper;
    tCommWrapper.useDefaultComm();
    std::vector<double> tValues = {67.5, 74.25, 81, 87.75, 94.5, 101.25, 108, 114.75, 121.5, 128.25, 135};
    Plato::StandardVector<double> tSamples(tValues);
    tValues = {0, 0.07147, 0.2510, 0.4672, 0.6668, 0.8207, 0.9209, 0.9741, 0.9951, 0.9997, 1};
    Plato::StandardVector<double> tSromCDF(tValues);
    tValues = {0, 0.0714785, 0.251019, 0.467237, 0.666808, 0.820732, 0.920897, 0.974047, 0.994957, 0.999721, 0.999987};
    Plato::StandardVector<double> tMonteCarloCDF(tValues);
    Plato::print_cumulative_distribution_function_to_file(tCommWrapper, tSromCDF, tMonteCarloCDF, tSamples);

    std::ifstream tReadFile;
    tReadFile.open("plato_cdf_output.txt");
    std::string tInputString;
    std::stringstream tReadData;
    while(tReadFile >> tInputString)
    {
        tReadData << tInputString.c_str();
    }
    tReadFile.close();
    Plato::system("rm -f plato_cdf_output.txt");

    std::stringstream tGold("");
    tGold << "PlatoEnginev.1.0:Copyright2018,NationalTechnology&EngineeringSolutionsofSandia,LLC(NTESS).";
    tGold << "SamplesMC-CDFSROM-CDF6.75000000e+010.00000000e+000.00000000e+007.42500000e+017.14785000e-027.14700000e-02";
    tGold << "8.10000000e+012.51019000e-012.51000000e-018.77500000e+014.67237000e-014.67200000e-019.45000000e+01";
    tGold << "6.66808000e-016.66800000e-011.01250000e+028.20732000e-018.20700000e-011.08000000e+029.20897000e-019.20900000e-01";
    tGold << "1.14750000e+029.74047000e-019.74100000e-011.21500000e+029.94957000e-019.95100000e-011.28250000e+029.99721000e-01";
    tGold << "9.99700000e-011.35000000e+029.99987000e-011.00000000e+00";
    ASSERT_STREQ(tReadData.str().c_str(), tGold.str().c_str());
}

TEST(PlatoTest, OutputCumulativeDistributionFunctionErrors)
{
    size_t tSize = 5;
    Plato::CommWrapper tCommWrapper;
    Plato::StandardVector<double> tSamples(tSize);
    Plato::StandardVector<double> tSromCDF(tSize);
    Plato::StandardVector<double> tMonteCarloCDF(tSize);
    ASSERT_THROW(Plato::output_cumulative_distribution_function(tCommWrapper, tSromCDF, tMonteCarloCDF, tSamples), std::runtime_error);
    tCommWrapper.useDefaultComm();
    ASSERT_NO_THROW(Plato::output_cumulative_distribution_function(tCommWrapper, tSromCDF, tMonteCarloCDF, tSamples));

    Plato::StandardVector<double> tSromCDF_1(tSize + 1u);
    ASSERT_THROW(Plato::output_cumulative_distribution_function(tCommWrapper, tSromCDF_1, tMonteCarloCDF, tSamples), std::runtime_error);
    ASSERT_NO_THROW(Plato::output_cumulative_distribution_function(tCommWrapper, tSromCDF, tMonteCarloCDF, tSamples));

    Plato::StandardVector<double> tSamples_1(tSize + 1u);
    ASSERT_THROW(Plato::output_cumulative_distribution_function(tCommWrapper, tSromCDF, tMonteCarloCDF, tSamples_1), std::runtime_error);
    ASSERT_NO_THROW(Plato::output_cumulative_distribution_function(tCommWrapper, tSromCDF, tMonteCarloCDF, tSamples));

    Plato::StandardVector<double> tMonteCarloCDF_1(tSize + 1u);
    ASSERT_THROW(Plato::output_cumulative_distribution_function(tCommWrapper, tSromCDF, tMonteCarloCDF_1, tSamples), std::runtime_error);
    ASSERT_NO_THROW(Plato::output_cumulative_distribution_function(tCommWrapper, tSromCDF, tMonteCarloCDF, tSamples));
}

TEST(PlatoTest, OutputCumulativeDistributionFunction)
{
    Plato::CommWrapper tCommWrapper;
    tCommWrapper.useDefaultComm();
    std::vector<double> tValues = {67.5, 74.25, 81, 87.75, 94.5, 101.25, 108, 114.75, 121.5, 128.25, 135};
    Plato::StandardVector<double> tSamples(tValues);
    tValues = {0, 0.07147, 0.2510, 0.4672, 0.6668, 0.8207, 0.9209, 0.9741, 0.9951, 0.9997, 1};
    Plato::StandardVector<double> tSromCDF(tValues);
    tValues = {0, 0.0714785, 0.251019, 0.467237, 0.666808, 0.820732, 0.920897, 0.974047, 0.994957, 0.999721, 0.999987};
    Plato::StandardVector<double> tMonteCarloCDF(tValues);
    Plato::print_cumulative_distribution_function_to_file(tCommWrapper, tSromCDF, tMonteCarloCDF, tSamples);

    std::ifstream tReadFile;
    tReadFile.open("plato_cdf_output.txt");
    std::string tInputString;
    std::stringstream tReadData;
    while(tReadFile >> tInputString)
    {
        tReadData << tInputString.c_str();
    }
    tReadFile.close();
    Plato::system("rm -f plato_cdf_output.txt");

    std::stringstream tGold("");
    tGold << "PlatoEnginev.1.0:Copyright2018,NationalTechnology&EngineeringSolutionsofSandia,LLC(NTESS).";
    tGold << "SamplesMC-CDFSROM-CDF6.75000000e+010.00000000e+000.00000000e+007.42500000e+017.14785000e-027.14700000e-02";
    tGold << "8.10000000e+012.51019000e-012.51000000e-018.77500000e+014.67237000e-014.67200000e-019.45000000e+01";
    tGold << "6.66808000e-016.66800000e-011.01250000e+028.20732000e-018.20700000e-011.08000000e+029.20897000e-019.20900000e-01";
    tGold << "1.14750000e+029.74047000e-019.74100000e-011.21500000e+029.94957000e-019.95100000e-011.28250000e+029.99721000e-01";
    tGold << "9.99700000e-011.35000000e+029.99987000e-011.00000000e+00";
    ASSERT_STREQ(tReadData.str().c_str(), tGold.str().c_str());
}

TEST(PlatoTest, Uniform)
{
    const double tLowerBound = 2;
    const double tUpperBound = 7;
    Plato::UniformDistribution<double> tDistribution(tLowerBound, tUpperBound);

    // ********** TEST STATISTICS FOR UNIFORM DISTRIBUTION **********
    const double tTolerance = 1e-5;
    EXPECT_NEAR(tLowerBound, tDistribution.lower(), tTolerance);
    EXPECT_NEAR(tUpperBound, tDistribution.upper(), tTolerance);
    double tGoldValue = 4.5;
    EXPECT_NEAR(tGoldValue, tDistribution.mean(), tTolerance);
    tGoldValue = (1. / 12.) * (tUpperBound - tLowerBound) * (tUpperBound - tLowerBound);
    EXPECT_NEAR(tGoldValue, tDistribution.variance(), tTolerance);
    tGoldValue = std::log(tUpperBound - tLowerBound);
    EXPECT_NEAR(tGoldValue, tDistribution.entropy(), tTolerance);
    // ********** TEST PDF **********
    std::vector<double> tSamples;
    tSamples.push_back(1);
    tSamples.push_back(2);
    tSamples.push_back(3);
    tSamples.push_back(4);
    tSamples.push_back(5);
    tSamples.push_back(6);
    tSamples.push_back(7);
    tSamples.push_back(8);
    std::vector<double> tGoldPDF;
    tGoldPDF.push_back(0);
    tGoldPDF.push_back(0.2);
    tGoldPDF.push_back(0.2);
    tGoldPDF.push_back(0.2);
    tGoldPDF.push_back(0.2);
    tGoldPDF.push_back(0.2);
    tGoldPDF.push_back(0.2);
    tGoldPDF.push_back(0);
    for(size_t tIndex = 0; tIndex < tGoldPDF.size(); tIndex++)
    {
        EXPECT_NEAR(tGoldPDF[tIndex], tDistribution.pdf(tSamples[tIndex]), tTolerance);
    }
    // ********** TEST CDF **********
    std::vector<double> tGoldCDF;
    tGoldCDF.push_back(0);
    tGoldCDF.push_back(0);
    tGoldCDF.push_back(.2);
    tGoldCDF.push_back(.4);
    tGoldCDF.push_back(.6);
    tGoldCDF.push_back(.8);
    tGoldCDF.push_back(1);
    tGoldCDF.push_back(1);
    for(size_t tIndex = 0; tIndex < tGoldCDF.size(); tIndex++)
    {
        EXPECT_NEAR(tGoldCDF[tIndex], tDistribution.cdf(tSamples[tIndex]), tTolerance);
    }
    // ********** TEST MOMENTS **********
    size_t tNumMoments = 8;
    for(size_t tOrder = 0; tOrder <= tNumMoments; tOrder++)
    {
        double tExponent = tOrder + 1u;
        double tGold = (std::pow(tUpperBound, tExponent) - std::pow(tLowerBound, tExponent))
                / (tExponent * (tUpperBound - tLowerBound));
        EXPECT_NEAR(tGold, tDistribution.moment(tOrder), tTolerance);
    }
}

TEST(PlatoTest, Normal)
{
    const double tMean = 0;
    const double tSigma = 1;

    double tEndRange = 1e3;
    double tBeginRange = -1e3;
    double tIncrement = 0.1;
    double tRange = ((tEndRange - tBeginRange) / tIncrement) + 1;
    std::vector<double> tNumbers(tRange);

    std::vector<double> tPDF(tRange);
    std::vector<double> tCDF(tRange);
    for(size_t tIndex = 0; tIndex < tRange; tIndex++)
    {
        tNumbers[tIndex] = tBeginRange + (tIncrement * tIndex);
        tPDF[tIndex] = Plato::normal_pdf<double>(tNumbers[tIndex], tMean, tSigma);
        tCDF[tIndex] = Plato::normal_cdf<double>(tNumbers[tIndex], tMean, tSigma);
    }

    const double tBaseValue = 0;
    const double tTolerance = 1e-3;
    double tValue = std::accumulate(tPDF.begin(), tPDF.end(), tBaseValue) / tRange;
    EXPECT_NEAR(tValue, tMean, tTolerance);
}

TEST(PlatoTest, SromCDF)
{
    double tSample = 0.276806509167094;
    Plato::StandardVector<double> tSamples(4, 0.);
    tSamples[0] = 0.276806509167094;
    tSamples[1] = 0.431107226622461;
    tSamples[2] = 0.004622102620248;
    tSamples[3] = 0.224162021074166;
    Plato::StandardVector<double> tSampleProbabilities(4, 0.);
    tSampleProbabilities[0] = 0.25;
    tSampleProbabilities[1] = 0.25;
    tSampleProbabilities[2] = 0.25;
    tSampleProbabilities[3] = 0.25;
    double tSigma = 1e-3;

    double tOutput = Plato::compute_srom_cdf<double>(tSample, tSigma, tSamples, tSampleProbabilities);

    double tGold = 0.625;
    double tTolerance = 1e-4;
    EXPECT_NEAR(tGold, tOutput, tTolerance);
}

TEST(PlatoTest, RawMoments)
{
    Plato::StandardVector<double> tSamples(4, 0.);
    tSamples[0] = 0.276806509167094;
    tSamples[1] = 0.431107226622461;
    tSamples[2] = 0.004622102620248;
    tSamples[3] = 0.224162021074166;
    Plato::StandardVector<double> tSampleProbabilities(4, 0.);
    tSampleProbabilities[0] = 0.25;
    tSampleProbabilities[1] = 0.25;
    tSampleProbabilities[2] = 0.25;
    tSampleProbabilities[3] = 0.25;

    Plato::StandardVector<double> tMoments(4, 0.);
    for(size_t tIndex = 0; tIndex < tMoments.size(); tIndex++)
    {
        double tOrder = tIndex + static_cast<size_t>(1);
        tMoments[tIndex] = Plato::compute_raw_moment(tOrder, tSamples, tSampleProbabilities);
    }

    Plato::StandardVector<double> tGold(4, 0.);
    tGold[0] = 0.234174464870992;
    tGold[1] = 0.078186314972017;
    tGold[2] = 0.028149028892565;
    tGold[3] = 0.010734332952929;
    PlatoTest::checkVectorData(tMoments, tGold);
}

TEST(PlatoTest, CentralMoments)
{
    Plato::StandardVector<double> tSamples(4, 0.);
    tSamples[0] = 0.276806509167094;
    tSamples[1] = 0.431107226622461;
    tSamples[2] = 0.004622102620248;
    tSamples[3] = 0.224162021074166;
    Plato::StandardVector<double> tSampleProbabilities(4, 0.);
    tSampleProbabilities[0] = 0.25;
    tSampleProbabilities[1] = 0.25;
    tSampleProbabilities[2] = 0.25;
    tSampleProbabilities[3] = 0.25;

    Plato::StandardVector<double> tMoments(4, 0.);
    for(size_t tIndex = 0; tIndex < tMoments.size(); tIndex++)
    {
        double tOrder = tIndex + static_cast<size_t>(1);
        tMoments[tIndex] = Plato::compute_central_moment(tOrder, tSamples, tSampleProbabilities);
    }

    Plato::StandardVector<double> tGold(4, 0.);
    tGold[0] = 0.0;
    tGold[1] = 0.023348634974401761;
    tGold[2] = -0.00109551777743925;
    tGold[3] = 0.001071021123917853;
    PlatoTest::checkVectorData(tMoments, tGold);
}

TEST(PlatoTest, factorial)
{
    size_t tGold = 1;
    size_t tValue = Plato::factorial<size_t>(0);
    EXPECT_EQ(tGold, tValue);

    tGold = 1;
    tValue = Plato::factorial<size_t>(1);
    EXPECT_EQ(tGold, tValue);

    tGold = 362880;
    tValue = Plato::factorial<size_t>(9);
    EXPECT_EQ(tGold, tValue);
}

TEST(PlatoTest, Beta)
{
    double tAlpha = 1;
    double tBeta = 3;
    double tValue = Plato::beta<double>(tAlpha, tBeta);

    double tTolerance = 1e-6;
    double tGold = 1. / 3.;
    EXPECT_NEAR(tGold, tValue, tTolerance);
}

TEST(PlatoTest, PochhammerSymbol)
{
    // TEST ONE: NON-FINITE NUMBER CASE
    double tOutput = Plato::pochhammer_symbol<double>(-2, 0);
    const double tTolerance = 1e-5;
    EXPECT_NEAR(0, tOutput, tTolerance);

    // TEST TWO: FINITE NUMBER CASE
    tOutput = Plato::pochhammer_symbol<double>(2.166666666666666, 4.333333333333333);
    double tGold = 265.98433449717857;
    EXPECT_NEAR(tGold, tOutput, tTolerance);
}

TEST(PlatoTest, BetaMoment)
{
    size_t tOrder = 3;
    double tAlpha = 2.166666666666666;
    double tBeta = 4.333333333333333;
    double tValue = Plato::beta_moment<double>(tOrder, tAlpha, tBeta);

    double tTolerance = 1e-6;
    double tGold = 0.068990559186638;
    EXPECT_NEAR(tGold, tValue, tTolerance);
}

TEST(PlatoTest, ComputeShapeParameters)
{
    const double tMean = 90;
    const double tMaxValue = 135;
    const double tMinValue = 67.5;
    const double tVariance = 135;
    double tAlphaShapeParameter = 0;
    double tBetaShapeParameter = 0;
    Plato::shape_parameters<double>(tMinValue, tMaxValue, tMean, tVariance, tAlphaShapeParameter, tBetaShapeParameter);

    const double tTolerance = 1e-6;
    const double tGoldAlpha = 2.166666666666666;
    const double tGoldBeta = 4.333333333333333;
    EXPECT_NEAR(tGoldBeta, tBetaShapeParameter, tTolerance);
    EXPECT_NEAR(tGoldAlpha, tAlphaShapeParameter, tTolerance);
}

TEST(PlatoTest, IncompleteBeta)
{
    double tSample = 1.;
    const double tAlpha = 2.166666666666666;
    const double tBeta = 4.333333333333333;

    double tOutput = Plato::incomplete_beta<double>(tSample, tAlpha, tBeta);

    const double tTolerance = 1e-5;
    const double tGold = Plato::beta<double>(tAlpha, tBeta);
    EXPECT_NEAR(tOutput, tGold, tTolerance);
}

TEST(PlatoTest, BetaPDF)
{
    const size_t tRange = 4;
    std::vector<double> tPDF(tRange);
    std::vector<double> tShapeParam(tRange);
    tShapeParam[0] = 0.5;
    tShapeParam[1] = 1;
    tShapeParam[2] = 2;
    tShapeParam[3] = 4;
    const double tSample = 0.5;
    for(size_t tIndex = 0; tIndex < tRange; tIndex++)
    {
        tPDF[tIndex] = Plato::beta_pdf<double>(tSample, tShapeParam[tIndex], tShapeParam[tIndex]);
    }

    const double tTolerance = 1e-6;
    std::vector<double> tGoldPDF(tRange, 0.);
    tGoldPDF[0] = 0.636619772367582;
    tGoldPDF[1] = 1.0;
    tGoldPDF[2] = 1.5;
    tGoldPDF[3] = 2.1875;
    for(size_t tIndex = 0; tIndex < tRange; tIndex++)
    {
        EXPECT_NEAR(tPDF[tIndex], tGoldPDF[tIndex], tTolerance);
    }
}

TEST(PlatoTest, BetaCDF)
{
    const double tBeta = 3;
    const double tSample = 0.5;
    const size_t tRange = 11;
    std::vector<double> tCDF(tRange, 0.);
    for(size_t tIndex = 0; tIndex < tRange; tIndex++)
    {
        tCDF[tIndex] = Plato::beta_cdf<double>(tSample, tIndex, tBeta);
    }

    const double tTolerance = 1e-6;
    std::vector<double> tGoldCDF(tRange, 0.);
    tGoldCDF[0] = 1;
    tGoldCDF[1] = 0.875;
    tGoldCDF[2] = 0.6875;
    tGoldCDF[3] = 0.5;
    tGoldCDF[4] = 0.34375;
    tGoldCDF[5] = 0.2265625;
    tGoldCDF[6] = 0.14453125;
    tGoldCDF[7] = 0.08984375;
    tGoldCDF[8] = 0.0546875;
    tGoldCDF[9] = 0.03271484375;
    tGoldCDF[10] = 0.019287109375;
    for(size_t tIndex = 0; tIndex < tRange; tIndex++)
    {
        EXPECT_NEAR(tCDF[tIndex], tGoldCDF[tIndex], tTolerance);
    }
}

TEST(PlatoTest, BetaCDF2)
{
    // BUILD BETA DISTRIBUTION
    const double tMean = 90;
    const double tMax = 135;
    const double tMin = 67.5;
    const double tVariance = 135;
    Plato::BetaDistribution<double> tBetaDistribution(tMin, tMax, tMean, tVariance);

    // CONSTRUCT MONTE CARLO SAMPLE VECTOR
    const size_t tNumSamples = 1000;
    const size_t tLength = tNumSamples + static_cast<size_t>(1);
    const double tDelta = 1.0 / tNumSamples;
    std::vector<double> tSamples(tLength);
    for(size_t tIndex = 1; tIndex < tLength; tIndex++)
    {
        size_t tPreviousIndex = tIndex - static_cast<size_t>(1);
        tSamples[tIndex] = tSamples[tPreviousIndex] + tDelta;
    }

    // COMPUTE CDF
    std::vector<double> tCDF(tLength);
    for(size_t tIndex = 0; tIndex < tSamples.size(); tIndex++)
    {
        tCDF[tIndex] = tBetaDistribution.cdf(tSamples[tIndex]);
    }

    // TEST CDF VALUES
    const double tTolerance = 1e-4;
    std::vector<double> tGold = PlatoTest::get_gold_beta_cdf_values();
    EXPECT_EQ(tCDF.size(), tGold.size());
    for(size_t tIndex = 0; tIndex < tSamples.size(); tIndex++)
    {
        EXPECT_NEAR(tCDF[tIndex], tGold[tIndex], tTolerance);
    }
}

TEST(PlatoTest, PlotBetaCDF)
{
    // BUILD BETA DISTRIBUTION
    const double tMean = 90;
    const double tMax = 135;
    const double tMin = 67.5;
    const double tVariance = 135;
    Plato::BetaDistribution<double> tBetaDistribution(tMin, tMax, tMean, tVariance);

    // CONSTRUCT MONTE CARLO SAMPLE VECTOR
    const size_t tNumSamples = 100;
    const size_t tLength = tNumSamples + static_cast<size_t>(1);
    const double tDelta = 1.0 / tNumSamples;
    Plato::StandardVector<double> tSamplesMC(tLength);
    for(size_t tIndex = 1; tIndex < tLength; tIndex++)
    {
        size_t tPreviousIndex = tIndex - static_cast<size_t>(1);
        tSamplesMC[tIndex] = tSamplesMC[tPreviousIndex] + tDelta;
    }

    // COMPUTE MONTE CARLO CDF
    Plato::StandardVector<double> tMonteCarloCDF(tLength);
    EXPECT_EQ(tMonteCarloCDF.size(), tSamplesMC.size());
    for(size_t tIndex = 0; tIndex < tSamplesMC.size(); tIndex++)
    {
        tMonteCarloCDF[tIndex] = tBetaDistribution.cdf(tSamplesMC[tIndex]);
    }

    // POSE SROM PROBLEM WITH KNOWN SOLUTION
    Plato::SromInputs<double> tStatsInputs;
    tStatsInputs.mDistribution = Plato::DistributionName::beta;
    tStatsInputs.mMean = 90.;
    tStatsInputs.mUpperBound = 135.;
    tStatsInputs.mLowerBound = 67.5;
    tStatsInputs.mVariance = 135.;
    tStatsInputs.mNumSamples = 10;
    tStatsInputs.mMaxNumDistributionMoments = 4;

    // SOLVE SROM PROBLEM
    Plato::SromDiagnostics<double> tDiagnostics;
    Plato::AlgorithmInputsKSAL<double> tInputsKSAL;
    Plato::SromOutputs<double> tOutput;
    Plato::solve_srom_problem(tStatsInputs, tInputsKSAL, tDiagnostics, tOutput);

    // GATHER OUTPUT FROM SROM PROBLEM
    Plato::StandardVector<double> tSromCDF(tLength);
    Plato::StandardVector<double> tProbsSROM(tStatsInputs.mNumSamples);
    Plato::StandardVector<double> tSamplesSROM(tStatsInputs.mNumSamples);
    for(size_t tIndex = 0; tIndex < tStatsInputs.mNumSamples; tIndex++)
    {
        tSamplesSROM[tIndex] = tOutput.mSamples[0][tIndex];
        tProbsSROM[tIndex] = tOutput.mProbabilities[tIndex];
    }

    // NORMALIZED SROM OUTPUT
    Plato::StandardVector<double> tNormalizedSamplesSROM(tStatsInputs.mNumSamples);
    for(size_t tIndex = 0; tIndex < tSamplesSROM.size(); tIndex++)
    {
        tNormalizedSamplesSROM[tIndex] = Plato::normalize(tStatsInputs.mLowerBound, tStatsInputs.mUpperBound, tSamplesSROM[tIndex]);
    }

    // TEST SROM PROBLEM OUTPUT
    const double tTolerance = 1e-2;
    std::vector<double> tGoldProbs = {0.09287332494792723, 0.098032727584988294, 0.097784878170723316, 0.063718049360904999,
                                      0.081377138697984519, 0.052535721635177612, 0.16198785891457218, 0.20081170433147152,
                                      0.071970888684988521, 0.078938799372327048};
    std::vector<double> tGoldNormalizedSamples = {0.088999881918310722, 0.13950080170092727, 0.18889828333364414, 0.76585608031725494,
                                                  0.38103844910769097, 0.41190121356243764, 0.29265512140149968, 0.47641830192799917,
                                                  0.34520742669018528, 0.25598542091673138};
    for(size_t tIndex = 0; tIndex < tProbsSROM.size(); tIndex++)
    {
        EXPECT_NEAR(tProbsSROM[tIndex], tGoldProbs[tIndex], tTolerance);
        EXPECT_NEAR(tNormalizedSamplesSROM[tIndex], tGoldNormalizedSamples[tIndex], tTolerance);
    }

    // CALL SROM CDF PLOT FUNCTION
    Plato::compute_srom_cdf_plot(tSamplesMC, tNormalizedSamplesSROM, tProbsSROM, tSromCDF);

    // TEST CDF OUTPUT
    std::vector<double> tGoldSromCDF = PlatoTest::get_gold_srom_cdf_values();
    for(size_t tIndex = 0; tIndex < tProbsSROM.size(); tIndex++)
    {
        EXPECT_NEAR(tSromCDF[tIndex], tGoldSromCDF[tIndex], tTolerance);
    }
}

TEST(PlatoTest, BetaDistribution)
{
    const double tMean = 90;
    const double tMax = 135;
    const double tMin = 67.5;
    const double tVariance = 135;
    Plato::BetaDistribution<double> tDistribution(tMin, tMax, tMean, tVariance);

    // TEST INPUTS
    const double tTolerance = 1e-5;
    EXPECT_NEAR(tMin, tDistribution.min(), tTolerance);
    EXPECT_NEAR(tMax, tDistribution.max(), tTolerance);
    EXPECT_NEAR(tMean, tDistribution.mean(), tTolerance);
    EXPECT_NEAR(tVariance, tDistribution.variance(), tTolerance);

    // TEST BETA PDF & CDF
    double tSample = 0.276806509167094;
    double tGoldPDF = 2.179085850493935;
    EXPECT_NEAR(tGoldPDF, tDistribution.pdf(tSample), tTolerance);
    double tGoldCDF = 0.417022004702574;
    EXPECT_NEAR(tGoldCDF, tDistribution.cdf(tSample), tTolerance);

    // TEST BETA MOMENTS
    const size_t tNumMoments = 4;
    Plato::StandardVector<double> tGoldMoments(tNumMoments);
    tGoldMoments[0] = 0.333333333333333;
    tGoldMoments[1] = 0.140740740740740;
    tGoldMoments[2] = 0.068990559186638;
    tGoldMoments[3] = 0.037521181312031;
    for(size_t tIndex = 0; tIndex < tNumMoments; tIndex++)
    {
        size_t tOrder = tIndex + 1;
        EXPECT_NEAR(tGoldMoments[tIndex], tDistribution.moment(tOrder), tTolerance);
    }
}

TEST(PlatoTest, SromObjectiveTestOne)
{
    // ********* ALLOCATE BETA DISTRIBUTION *********
    const double tMean = 90;
    const double tMax = 135;
    const double tMin = 67.5;
    const double tVariance = 135;
    std::shared_ptr<Plato::BetaDistribution<double>> tDistribution =
            std::make_shared<Plato::BetaDistribution<double>>(tMin, tMax, tMean, tVariance);

    // ********* SET TEST DATA: SAMPLES AND PROBABILITIES *********
    const size_t tNumVectors = 2;
    const size_t tNumSamples = 4;
    Plato::StandardMultiVector<double> tControl(tNumVectors, tNumSamples);
    size_t tVectorIndex = 0;
    tControl(tVectorIndex, 0) = 0.276806509167094;
    tControl(tVectorIndex, 1) = 0.431107226622461;
    tControl(tVectorIndex, 2) = 0.004622102620248;
    tControl(tVectorIndex, 3) = 0.224162021074166;
    tVectorIndex = 1;
    tControl[tVectorIndex].fill(0.25);

    // ********* TEST OBJECTIVE FUNCTION *********
    const size_t tMaxNumMoments = 4;
    Plato::SromObjective<double> tObjective(tDistribution, tMaxNumMoments, tNumSamples);
    tObjective.setCdfMisfitTermWeight(1);
    tObjective.setMomentMisfitTermWeight(1);
    double tValue = tObjective.value(tControl);
    double tTolerance = 1e-5;
    double tGold = 0.617109315688096;
    EXPECT_NEAR(tGold, tValue, tTolerance);

    // ********* TEST OBJECTIVE GRADIENT *********
    Plato::StandardMultiVector<double> tGradient(tNumVectors, tNumSamples);
    tObjective.gradient(tControl, tGradient);
    Plato::StandardMultiVector<double> tGradientGold(tNumVectors, tNumSamples);
    tVectorIndex = 0;
    tGradientGold(tVectorIndex, 0) = -2.010045017107233;
    tGradientGold(tVectorIndex, 1) = -3.878346258927178;
    tGradientGold(tVectorIndex, 2) = -0.237208262654126;
    tGradientGold(tVectorIndex, 3) = -1.271234346951175;
    tVectorIndex = 1;
    tGradientGold(tVectorIndex, 0) = -0.524038145360132;
    tGradientGold(tVectorIndex, 1) = -2.239056684273221;
    tGradientGold(tVectorIndex, 2) = 0.493570515676146;
    tGradientGold(tVectorIndex, 3) = -0.104442116117926;
    PlatoTest::checkMultiVectorData(tGradient, tGradientGold);
}

TEST(PlatoTest, SromObjectiveTestTwo_UncorrelatedTwoDimRandVec)
{
    // ********* ALLOCATE BETA DISTRIBUTION *********
    const double tMean = 90;
    const double tMax = 135;
    const double tMin = 67.5;
    const double tVariance = 135;
    std::shared_ptr<Plato::BetaDistribution<double>> tDistribution =
            std::make_shared<Plato::BetaDistribution<double>>(tMin, tMax, tMean, tVariance);

    // ********* SET TEST DATA: SAMPLES AND PROBABILITIES *********
    const size_t tNumVectors = 3;
    const size_t tNumSamples = 4;
    Plato::StandardMultiVector<double> tControl(tNumVectors, tNumSamples);
    size_t tVectorIndex = 0;
    tControl(tVectorIndex, 0) = 0.276806509167094;
    tControl(tVectorIndex, 1) = 0.004622102620248;
    tControl(tVectorIndex, 2) = 0.376806509167094;
    tControl(tVectorIndex, 3) = 0.104622102620248;
    tVectorIndex = 1;
    tControl(tVectorIndex, 0) = 0.431107226622461;
    tControl(tVectorIndex, 1) = 0.224162021074166;
    tControl(tVectorIndex, 2) = 0.531107226622461;
    tControl(tVectorIndex, 3) = 0.324162021074166;
    tVectorIndex = 2;
    tControl[tVectorIndex].fill(0.25);

    // ********* TEST OBJECTIVE FUNCTION *********
    const size_t tRandomVecDim = 2;
    const size_t tMaxNumMoments = 4;
    Plato::SromObjective<double> tObjective(tDistribution, tMaxNumMoments, tNumSamples, tRandomVecDim);
    tObjective.setCdfMisfitTermWeight(1);
    tObjective.setMomentMisfitTermWeight(1);
    tObjective.setCorrelationMisfitTermWeight(1);
    double tValue = tObjective.value(tControl);
    double tTolerance = 1e-5;
    double tGold = 1.032230626961365;
    EXPECT_NEAR(tGold, tValue, tTolerance);

    // ********* TEST OBJECTIVE GRADIENT *********
    Plato::StandardMultiVector<double> tGradient(tNumVectors, tNumSamples);
    tObjective.gradient(tControl, tGradient);
    Plato::StandardMultiVector<double> tGradientGold(tNumVectors, tNumSamples);
    tVectorIndex = 0;
    tGradientGold(tVectorIndex, 0) = -2.42724408126656;
    tGradientGold(tVectorIndex, 1) = -0.337450847795798;
    tGradientGold(tVectorIndex, 2) = -3.887791716578634;
    tGradientGold(tVectorIndex, 3) = -1.076413326527892;
    tVectorIndex = 1;
    tGradientGold(tVectorIndex, 0) = 0.096246202011561;
    tGradientGold(tVectorIndex, 1) = 0.520617569090164;
    tGradientGold(tVectorIndex, 2) = -0.321363712239195;
    tGradientGold(tVectorIndex, 3) = 0.384504837554259;
    tVectorIndex = 2;
    tGradientGold(tVectorIndex, 0) = -0.53206506489113;
    tGradientGold(tVectorIndex, 1) = 0.619653114279367;
    tGradientGold(tVectorIndex, 2) = -1.84853491196106;
    tGradientGold(tVectorIndex, 3) = 0.426963908092988;
    PlatoTest::checkMultiVectorData(tGradient, tGradientGold);
}

TEST(PlatoTest, SromObjectiveTestTwo_CorrelatedTwoDimRandVec)
{
    // ********* ALLOCATE BETA DISTRIBUTION *********
    const double tMean = 90;
    const double tMax = 135;
    const double tMin = 67.5;
    const double tVariance = 135;
    std::shared_ptr<Plato::BetaDistribution<double>> tDistribution =
            std::make_shared<Plato::BetaDistribution<double>>(tMin, tMax, tMean, tVariance);

    // ********* SET TEST DATA: SAMPLES AND PROBABILITIES *********
    const size_t tNumVectors = 3;
    const size_t tNumSamples = 4;
    Plato::StandardMultiVector<double> tControl(tNumVectors, tNumSamples);
    size_t tVectorIndex = 0;
    tControl(tVectorIndex, 0) = 0.375040433304479;
    tControl(tVectorIndex, 1) = 0.328111162027339;
    tControl(tVectorIndex, 2) = 0.274681002534179;
    tControl(tVectorIndex, 3) = 0.334742519844096;
    tVectorIndex = 1;
    tControl(tVectorIndex, 0) = 0.414822395072085;
    tControl(tVectorIndex, 1) = 0.335056628176354;
    tControl(tVectorIndex, 2) = 0.272217383599573;
    tControl(tVectorIndex, 3) = 0.347126327711567;
    tVectorIndex = 2;
    tControl[tVectorIndex].fill(0.25);

    const size_t tRandomVecDim = 2;
    Plato::StandardMultiVector<double> tCorrelation(tRandomVecDim, tRandomVecDim);
    tCorrelation(0,0) = 0.163734737417027;
    tCorrelation(0,1) = 0.163286664100536;
    tCorrelation(1,0) = 0.163286664100536;
    tCorrelation(1,1) = 0.163653492690528;

    // ********* TEST OBJECTIVE FUNCTION *********
    const size_t tMaxNumMoments = 4;
    Plato::SromObjective<double> tObjective(tDistribution, tMaxNumMoments, tNumSamples, tRandomVecDim);
    tObjective.setCdfMisfitTermWeight(1);
    tObjective.setMomentMisfitTermWeight(1);
    tObjective.setCorrelationMisfitTermWeight(1);
    tObjective.setTruthCorrelationMatrix(tCorrelation);
    auto tValue = tObjective.value(tControl);
    auto tTolerance = 1e-4;
    auto tGold = 0.821198901404961;
    EXPECT_NEAR(tGold, tValue, tTolerance);

    // ********* TEST OBJECTIVE GRADIENT *********
    Plato::StandardMultiVector<double> tGradient(tNumVectors, tNumSamples);
    tObjective.gradient(tControl, tGradient);
    Plato::StandardMultiVector<double> tGradientGold(tNumVectors, tNumSamples);
    tVectorIndex = 0;
    tGradientGold(tVectorIndex, 0) = -2.64909865388309;
    tGradientGold(tVectorIndex, 1) = -1.29399447542632;
    tGradientGold(tVectorIndex, 2) = -0.485916817610198;
    tGradientGold(tVectorIndex, 3) = -1.85589143576364;
    tVectorIndex = 1;
    tGradientGold(tVectorIndex, 0) = -2.51193441109838;
    tGradientGold(tVectorIndex, 1) = -1.01799124946594;
    tGradientGold(tVectorIndex, 2) = -0.256417179857072;
    tGradientGold(tVectorIndex, 3) = -1.58873628951739;
    tVectorIndex = 2;
    tGradientGold(tVectorIndex, 0) = -2.02854765068563;
    tGradientGold(tVectorIndex, 1) = -0.912589079823457;
    tGradientGold(tVectorIndex, 2) = -0.790014838673253;
    tGradientGold(tVectorIndex, 3) = -0.937548637470705;
    PlatoTest::checkMultiVectorData(tGradient, tGradientGold, tTolerance);
}

TEST(PlatoTest, SromConstraint)
{
    // ********* SET TEST DATA: SAMPLES AND PROBABILITIES *********
    const size_t tNumVectors = 2;
    const size_t tNumSamples = 4;
    Plato::StandardMultiVector<double> tControl(tNumVectors, tNumSamples);
    size_t tVectorIndex = 0;
    tControl(tVectorIndex, 0) = 0.183183326166505;
    tControl(tVectorIndex, 1) = 0.341948604575779;
    tControl(tVectorIndex, 2) = 0.410656896223290;
    tControl(tVectorIndex, 3) = 0.064209040541960;
    tVectorIndex = 1;
    tControl(tVectorIndex, 0) = 0.434251989288042;
    tControl(tVectorIndex, 1) = 0.351721349341024;
    tControl(tVectorIndex, 2) = 0.001250000000000;
    tControl(tVectorIndex, 3) = 0.212776663693648;

    // ********* TEST CONSTRAINT EVALUATION *********
    std::shared_ptr<Plato::StandardVectorReductionOperations<double>> tReductions =
            std::make_shared<Plato::StandardVectorReductionOperations<double>>();
    Plato::SromConstraint<double> tConstraint(tReductions);
    double tValue = tConstraint.value(tControl);

    double tGoldValue = 0;
    double tTolerance = 1e-6;
    EXPECT_NEAR(tGoldValue, tValue, tTolerance);

    // ********* TEST CONSTRAINT GRADIENT *********
    Plato::StandardMultiVector<double> tGradient(tNumVectors, tNumSamples);
    tConstraint.gradient(tControl, tGradient);
    Plato::StandardMultiVector<double> tGradientGold(tNumVectors, tNumSamples);
    tVectorIndex = 0;
    tGradientGold(tVectorIndex, 0) = 0;
    tGradientGold(tVectorIndex, 1) = 0;
    tGradientGold(tVectorIndex, 2) = 0;
    tGradientGold(tVectorIndex, 3) = 0;
    tVectorIndex = 1;
    tGradientGold(tVectorIndex, 0) = 1;
    tGradientGold(tVectorIndex, 1) = 1;
    tGradientGold(tVectorIndex, 2) = 1;
    tGradientGold(tVectorIndex, 3) = 1;
    PlatoTest::checkMultiVectorData(tGradient, tGradientGold);
}

TEST(PlatoTest, NormalDistribution)
{
    double tMean = 1;
    double tStandardDeviation = 0.5;
    Plato::NormalDistribution<double> tDistribution(tMean, tStandardDeviation);

    double tGoldValue = 1;
    double tTolerance = 1e-6;
    EXPECT_NEAR(tGoldValue, tDistribution.mean(), tTolerance);
    tGoldValue = 0.5;
    EXPECT_NEAR(tGoldValue, tDistribution.sigma(), tTolerance);

    // ********* TEST GAUSSIAN PDF AND CDF *********
    double tSample = 0.2;
    tGoldValue = 0.221841669358911;
    EXPECT_NEAR(tGoldValue, tDistribution.pdf(tSample), tTolerance);
    tGoldValue = 0.054799291699558;
    EXPECT_NEAR(tGoldValue, tDistribution.cdf(tSample), tTolerance);

    // ********* TEST GAUSSIAN MOMENTS *********
    size_t tMaxNumMoments = 8;
    std::vector<double> tGoldMoments(tMaxNumMoments + 1u);
    tGoldMoments[0] = 1;
    tGoldMoments[1] = tMean;
    tGoldMoments[2] = std::pow(tMean, 2.) + std::pow(tStandardDeviation, 2.);
    tGoldMoments[3] = std::pow(tMean, 3.) + 3 * tMean * std::pow(tStandardDeviation, 2.);
    tGoldMoments[4] = std::pow(tMean, 4.) + 6 * std::pow(tMean, 2.) * std::pow(tStandardDeviation, 2.)
                      + 3 * std::pow(tStandardDeviation, 4.);
    tGoldMoments[5] = std::pow(tMean, 5.) + 10 * std::pow(tMean, 3.) * std::pow(tStandardDeviation, 2.)
                      + 15 * tMean * std::pow(tStandardDeviation, 4.);
    tGoldMoments[6] = std::pow(tMean, 6.) + 15 * std::pow(tMean, 4.) * std::pow(tStandardDeviation, 2.)
                      + 45 * std::pow(tMean, 2.) * std::pow(tStandardDeviation, 4.) + 15 * std::pow(tStandardDeviation, 6.);
    tGoldMoments[7] = std::pow(tMean, 7.) + 21 * std::pow(tMean, 5.) * std::pow(tStandardDeviation, 2.)
                      + 105 * std::pow(tMean, 3.) * std::pow(tStandardDeviation, 4.)
                      + 105 * tMean * std::pow(tStandardDeviation, 6.);
    tGoldMoments[8] = std::pow(tMean, 8.) + 28 * std::pow(tMean, 6.) * std::pow(tStandardDeviation, 2.)
                      + 210 * std::pow(tMean, 4.) * std::pow(tStandardDeviation, 4.)
                      + 420 * std::pow(tMean, 2.) * std::pow(tStandardDeviation, 6.)
                      + 105 * tMean * std::pow(tStandardDeviation, 8.);
    for(size_t tOrder = 0; tOrder <= tMaxNumMoments; tOrder++)
    {
        double tValue = tDistribution.moment(tOrder);
        EXPECT_NEAR(tGoldMoments[tOrder], tValue, tTolerance);
    }
}

TEST(PlatoTest, CheckSromObjectiveGradient_Uncorrelated)
{
    // ********* ALLOCATE BETA DISTRIBUTION *********
    const double tMean = 90;
    const double tMax = 135;
    const double tMin = 67.5;
    const double tVariance = 135;
    std::shared_ptr<Plato::BetaDistribution<double>> tDistribution =
            std::make_shared<Plato::BetaDistribution<double>>(tMin, tMax, tMean, tVariance);

    // ********* CHECK OBJECTIVE GRADIENT *********
    std::ostringstream tOutputMsg;
    const size_t tNumSamples = 4;
    const size_t tMaxNumMoments = 4;
    Plato::Diagnostics<double> tDiagnostics;
    Plato::SromObjective<double> tObjective(tDistribution, tMaxNumMoments, tNumSamples);

    const size_t tNumVectors = 2;
    Plato::StandardMultiVector<double> tControl(tNumVectors, tNumSamples);
    tDiagnostics.checkCriterionGradient(tObjective, tControl, tOutputMsg);
    EXPECT_TRUE(tDiagnostics.didGradientTestPassed());

    Plato::CommWrapper tComm(MPI_COMM_WORLD);
    if(tComm.myProcID() == static_cast<int>(0))
    {
        std::cout << tOutputMsg.str().c_str();
    }
}

TEST(PlatoTest, CheckSromObjectiveGradient_Correlated)
{
    // ********* ALLOCATE BETA DISTRIBUTION *********
    const double tMean = 90;
    const double tMax = 135;
    const double tMin = 67.5;
    const double tVariance = 135;
    std::shared_ptr<Plato::BetaDistribution<double>> tDistribution =
            std::make_shared<Plato::BetaDistribution<double>>(tMin, tMax, tMean, tVariance);

    // ********* CHECK OBJECTIVE GRADIENT *********
    std::ostringstream tOutputMsg;
    const size_t tNumSamples = 4;
    const size_t tRandomVecDim = 2;
    const size_t tMaxNumMoments = 4;
    Plato::Diagnostics<double> tDiagnostics;
    Plato::SromObjective<double> tObjective(tDistribution, tMaxNumMoments, tNumSamples, tRandomVecDim);

    Plato::StandardMultiVector<double> tCorrelation(tRandomVecDim, tRandomVecDim);
    tCorrelation(0,0) = 0.163734737417027;
    tCorrelation(0,1) = 0.163286664100536;
    tCorrelation(1,0) = 0.163286664100536;
    tCorrelation(1,1) = 0.163653492690528;
    tObjective.setTruthCorrelationMatrix(tCorrelation);

    const size_t tNumControlVectors = tRandomVecDim + 1;
    Plato::StandardMultiVector<double> tControl(tNumControlVectors, tNumSamples);
    tDiagnostics.checkCriterionGradient(tObjective, tControl, tOutputMsg);
    EXPECT_TRUE(tDiagnostics.didGradientTestPassed());

    Plato::CommWrapper tComm(MPI_COMM_WORLD);
    if(tComm.myProcID() == static_cast<int>(0))
    {
        std::cout << tOutputMsg.str().c_str();
    }
}

TEST(PlatoTest, CheckSromConstraintGradient)
{
    // ********* CHECK CONSTRAINT GRADIENT *********
    std::shared_ptr<Plato::StandardVectorReductionOperations<double>> tReductions =
            std::make_shared<Plato::StandardVectorReductionOperations<double>>();
    Plato::SromConstraint<double> tConstraint(tReductions);

    const size_t tNumVectors = 2;
    const size_t tNumSamples = 4;
    Plato::StandardMultiVector<double> tControl(tNumVectors, tNumSamples);

    std::ostringstream tOutputMsg;
    Plato::Diagnostics<double> tDiagnostics;
    tDiagnostics.checkCriterionGradient(tConstraint, tControl, tOutputMsg);
    EXPECT_TRUE(tDiagnostics.didGradientTestPassed());

    Plato::CommWrapper tComm(MPI_COMM_WORLD);
    if(tComm.myProcID() == static_cast<int>(0))
    {
        std::cout << tOutputMsg.str().c_str();
    }
}

TEST(PlatoTest, SolveSromProblem_CorrelatedVars_BetaDistribution)
{
    // POSE CORRELATION MATRIX
    Plato::io::MetaData tFileMetaData;
    tFileMetaData.mFilename = "correlation_matrix.txt";
    std::vector<std::vector<double>> tGold =
        { {0.142166323166496, 0.138671023863737}, {0.138671023863737, 0.141194790885173} };
    Plato::io::write_matrix_to_file(tGold, tFileMetaData);

    // POSE PROBLEM WITH KNOWN SOLUTION
    Plato::SromInputs<double, size_t> tStatsInputs;
    tStatsInputs.mDimensions = 2;
    tStatsInputs.mDistribution = Plato::DistributionName::beta;
    tStatsInputs.mMean = 30.;
    tStatsInputs.mUpperBound = 35.;
    tStatsInputs.mLowerBound = 20.;
    tStatsInputs.mVariance = 4.;
    tStatsInputs.mNumSamples = 5;
    tStatsInputs.mMaxNumDistributionMoments = 4;
    tStatsInputs.mCorrelationMatrixFilename = tFileMetaData.mFilename;

    // SOLVE SROM PROBLEM
    Plato::SromOutputs<double> tOutput;
    Plato::SromDiagnostics<double> tDiagnostics;
    Plato::AlgorithmInputsKSAL<double> tInputsKSAL;
    tInputsKSAL.mLimitedMemorySize = 6;
    Plato::solve_srom_problem(tStatsInputs, tInputsKSAL, tDiagnostics, tOutput);

    double tTol = 1e-2;
    std::vector<std::vector<double>> tGoldSamples =
        {{22.48753391885498,24.89758085232308,30.34886999333217,29.41033100339423,33.93022475922718},
         {22.75754703660045,29.70576425719733,29.25288508886058,31.13667083109212,31.43091708700306}};
    for(auto& tRow : tOutput.mSamples)
    {
        auto tRowIndex = &tRow - &tOutput.mSamples[0];
        for(auto& tCol : tRow)
        {
            auto tColIndex = &tCol - &tRow[0];
	    auto tRelativeError = std::abs(tCol - tGoldSamples[tRowIndex][tColIndex]) / tGoldSamples[tRowIndex][tColIndex];
	    //std::cout << "Sample Relative Error = " << tRelativeError << "\n";
            ASSERT_TRUE(tRelativeError < tTol);
        }
    }

    tTol = 1e-2;
    auto tSum = 0.0;
    std::vector<double> tGoldProbabilities =
        {0.3229842278588252,0.1621807059028493,0.1842816217593431,0.1876962703469281,0.1428344864216799};
    for(auto& tProb : tOutput.mProbabilities)
    {
        tSum += tProb;
        auto tIndex = &tProb - &tOutput.mProbabilities[0];
	auto tRelativeError = std::abs(tProb - tGoldProbabilities[tIndex]) / tGoldProbabilities[tIndex];
	//std::cout << "Prob Relative Error = " << tRelativeError << "\n";
        ASSERT_TRUE(tRelativeError < tTol);
    }
    auto tGoldSum = std::accumulate(tGoldProbabilities.begin(), tGoldProbabilities.end(), 0.0);
    EXPECT_NEAR(tGoldSum, tSum, tTol);

    Plato::system("rm -f correlation_matrix.txt");
}

TEST(PlatoTest, solve_srom_problem_beta)
{
    const double tTol = 1e-6;

    // POSE PROBLEM WITH KNOWN SOLUTION
    Plato::SromInputs<double, size_t> tStatsInputs;
    tStatsInputs.mDistribution = Plato::DistributionName::beta;
    tStatsInputs.mMean = 90.;
    tStatsInputs.mUpperBound = 135.;
    tStatsInputs.mLowerBound = 67.5;
    tStatsInputs.mVariance = 135.;
    tStatsInputs.mNumSamples = 4;
    tStatsInputs.mMaxNumDistributionMoments = 4;

    // SOLVE
    Plato::SromOutputs<double> tOutput;
    Plato::SromDiagnostics<double> tDiagnostics;
    Plato::AlgorithmInputsKSAL<double> tInputsKSAL;
    Plato::solve_srom_problem(tStatsInputs, tInputsKSAL, tDiagnostics, tOutput);

    // CHECK
    size_t tRandVecDim = 0;
    ASSERT_EQ(tOutput.mProbabilities.size(), tStatsInputs.mNumSamples);
    // GOLD SAMPLES
    EXPECT_NEAR(tOutput.mSamples[tRandVecDim][0], 78.648223523346431, tTol);
    EXPECT_NEAR(tOutput.mSamples[tRandVecDim][1], 87.571021455893685, tTol);
    EXPECT_NEAR(tOutput.mSamples[tRandVecDim][2], 99.32086371389596, tTol);
    EXPECT_NEAR(tOutput.mSamples[tRandVecDim][3], 110.99183323634628, tTol);
    // GOLD PROBABILITIES
    EXPECT_NEAR(tOutput.mProbabilities[0], 0.33023002965991671, tTol);
    EXPECT_NEAR(tOutput.mProbabilities[1], 0.30856864775148274, tTol);
    EXPECT_NEAR(tOutput.mProbabilities[2], 0.22787120519226264, tTol);
    EXPECT_NEAR(tOutput.mProbabilities[3], 0.13333298643496919, tTol);
    // expect total probability of unity
    const double tTotalProbability =
        tOutput.mProbabilities[0] + tOutput.mProbabilities[1] + tOutput.mProbabilities[2] + tOutput.mProbabilities[3];
    EXPECT_NEAR(tTotalProbability, 1.0000028690386313, tTol);
}

TEST(PlatoTest, solve_srom_problem_uniform)
{
    const double tTol = 1e-6;

    // POSE PROBLEM WITH KNOWN SOLUTION
    Plato::SromInputs<double, size_t> tStatsInputs;
    tStatsInputs.mDistribution = Plato::DistributionName::uniform;
    tStatsInputs.mMean = 0.;
    tStatsInputs.mUpperBound = 75.;
    tStatsInputs.mLowerBound = 25.;
    tStatsInputs.mVariance = 0.;
    tStatsInputs.mNumSamples = 5;
    tStatsInputs.mMaxNumDistributionMoments = 4;

    // SOLVE
    Plato::SromOutputs<double> tOutput;
    Plato::SromDiagnostics<double> tDiagnostics;
    Plato::AlgorithmInputsKSAL<double> tInputsKSAL;
    Plato::solve_srom_problem(tStatsInputs, tInputsKSAL, tDiagnostics, tOutput);

    // CHECK
    size_t tRandVecDim = 0;
    ASSERT_EQ(tOutput.mProbabilities.size(), tStatsInputs.mNumSamples);
    // GOLD SAMPLES
    EXPECT_NEAR(tOutput.mSamples[tRandVecDim][0], 33.56115301177298, tTol);
    EXPECT_NEAR(tOutput.mSamples[tRandVecDim][1], 41.869329138220166, tTol);
    EXPECT_NEAR(tOutput.mSamples[tRandVecDim][2], 50.230344395017241, tTol);
    EXPECT_NEAR(tOutput.mSamples[tRandVecDim][3], 58.605115000685984, tTol);
    EXPECT_NEAR(tOutput.mSamples[tRandVecDim][4], 66.974948215613182, tTol);
    // expect total probability of unity
    double tTotalProbability = 0;
    for(size_t tIndex = 0; tIndex < tStatsInputs.mNumSamples; tIndex++)
    {
        tTotalProbability += tOutput.mProbabilities[tIndex];
    }
    EXPECT_NEAR(tTotalProbability, 0.99992069897137525, tTol);
}

TEST(PlatoTest, SetSampleProbabilityPairsInitialGuess_UniformSampleInitialGuess)
{
    Plato::SromInputs<double> tSromInputs;
    tSromInputs.mNumSamples = 2;
    tSromInputs.mNumSamples = 2;
    Plato::AlgorithmInputsKSAL<double> tInputsKSAL;
    Plato::set_sample_probability_pairs_bounds(tSromInputs, tInputsKSAL);
    Plato::set_sample_probability_pairs_initial_guess(tSromInputs, tInputsKSAL);
    // TEST SAMPLES INITIAL GUESS
    const double tTol = 1e-6;
    EXPECT_NEAR((*tInputsKSAL.mInitialGuess)[0][0], 1.0 / 3.0, tTol);
    EXPECT_NEAR((*tInputsKSAL.mInitialGuess)[0][1], 2.0 / 3.0, tTol);
    // TEST PROBABILITIES INITIAL GUESS
    EXPECT_NEAR((*tInputsKSAL.mInitialGuess)[1][0], 0.5, tTol);
    EXPECT_NEAR((*tInputsKSAL.mInitialGuess)[1][1], 0.5, tTol);
    // TEST LOWER BOUNDS
    EXPECT_NEAR((*tInputsKSAL.mLowerBounds)[0][0], 0.0, tTol);
    EXPECT_NEAR((*tInputsKSAL.mLowerBounds)[0][1], 0.0, tTol);
    EXPECT_NEAR((*tInputsKSAL.mLowerBounds)[1][0], 0.0, tTol);
    EXPECT_NEAR((*tInputsKSAL.mLowerBounds)[1][1], 0.0, tTol);
    // TEST UPPER BOUNDS
    EXPECT_NEAR((*tInputsKSAL.mUpperBounds)[0][0], 1.0, tTol);
    EXPECT_NEAR((*tInputsKSAL.mUpperBounds)[0][1], 1.0, tTol);
    EXPECT_NEAR((*tInputsKSAL.mUpperBounds)[1][0], 1.0, tTol);
    EXPECT_NEAR((*tInputsKSAL.mUpperBounds)[1][1], 1.0, tTol);
}

TEST(PlatoTest, OutputSromDiagnostics)
{
    Plato::AlgorithmOutputsKSAL<double> tAlgorithmOutput;
    tAlgorithmOutput.mObjFuncValue = 1e-3;
    tAlgorithmOutput.mConstraints = std::make_shared<Plato::StandardVector<double>>(1 /* length */, 5e-4 /* base value */);
    Plato::SromDiagnostics<double> tDiagnostics;
    tDiagnostics.mCumulativeDistributionFunctionError = 0.01;
    tDiagnostics.mMomentErrors.resize(4);
    tDiagnostics.mMomentErrors[0] = 0.020;
    tDiagnostics.mMomentErrors[1] = 0.021;
    tDiagnostics.mMomentErrors[2] = 0.022;
    tDiagnostics.mMomentErrors[3] = 0.023;

    Plato::CommWrapper tCommWrapper;
    tCommWrapper.useDefaultComm();
    Plato::output_srom_diagnostics(tCommWrapper, tDiagnostics, tAlgorithmOutput);

    std::ifstream tInputFile;
    tInputFile.open("plato_srom_diagnostics.txt");
    std::string tData;
    std::stringstream tDataFromFile;
    while(tInputFile >> tData)
    {
        tDataFromFile << tData.c_str();
    }
    tInputFile.close();
    Plato::system("rm -f plato_srom_diagnostics.txt");

    std::stringstream tGold;
    tGold << "PlatoEnginev.1.0:Copyright2018,NationalTechnology&EngineeringSolutionsofSandia,LLC(NTESS).";
    tGold << "CumulativeDistributionFunction(CDF)Mismatch=1.000000e-02--------------------------------|";
    tGold << "StatisticalMomentsMismatch|--------------------------------|NameOrderError|--------------------------------|";
    tGold << "Mean12.000e-02||Variance22.100e-02||Skewness32.200e-02||Kurtosis42.300e-02|--------------------------------";
    tGold << "StochasticReducedOrderModel(SROM)optimizerdiagnostics.ObjectiveFunctionValue=1.000000e-03ConstraintValue=5.000000e-04";
    ASSERT_STREQ(tDataFromFile.str().c_str(), tGold.str().c_str());
}

} //namespace PlatoTest
